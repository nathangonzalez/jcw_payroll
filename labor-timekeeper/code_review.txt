=== server.js ===
import "dotenv/config";
import express from "express";
import helmet from "helmet";
import morgan from "morgan";
import cookieParser from "cookie-parser";
import multer from "multer";
import fs from "fs";
import path from "path";
import { openDb, id } from "./lib/db.js";
import { requireAuth, requireAdmin, cookieName, createSession, destroySession, verifyPin } from "./lib/auth.js";
import { weekStartYMD, weekDates, todayYMD } from "./lib/time.js";
import { transcribeAudio, parseVoiceCommand } from "./lib/voice.js";
import { buildMonthlyWorkbook, buildInvoiceWorkbook } from "./lib/export_excel.js";
import { generateWeeklyExports } from "./lib/export/generateWeekly.js";
import { generateMonthlyExport } from "./lib/export/generateMonthly.js";
import { getHolidaysForYear, getHolidaysInRange } from "./lib/holidays.js";

const app = express();
const db = openDb();

app.use(helmet({ contentSecurityPolicy: false })); // allow inline scripts in MVP
app.use(morgan("dev"));
app.use(express.json({ limit: "2mb" }));
app.use(cookieParser());
app.use(express.static("public"));

const upload = multer({ dest: "./data/uploads" });

/** Health */
app.get("/api/health", (req, res) => res.json({ ok: true, today: todayYMD() }));

/** Auth */
app.post("/api/login", (req, res) => {
  const { name, pin } = req.body || {};
  if (!name || !pin) return res.status(400).json({ error: "name and pin required" });
  const emp = db.prepare("SELECT * FROM employees WHERE name = ?").get(String(name));
  if (!emp) return res.status(401).json({ error: "Invalid login" });
  if (!verifyPin(pin, emp.pin_hash)) return res.status(401).json({ error: "Invalid login" });

  const { sid, expires } = createSession(db, emp.id);
  res.cookie(cookieName(), sid, {
    httpOnly: true,
    sameSite: "lax",
    secure: false, // set true behind HTTPS
    expires
  });
  res.json({ ok: true });
});

app.post("/api/logout", (req, res) => {
  const sid = req.cookies?.[cookieName()];
  if (sid) destroySession(db, sid);
  res.clearCookie(cookieName());
  res.json({ ok: true });
});

app.get("/api/me", requireAuth(db), (req, res) => {
  res.json({
    id: req.employee.id,
    name: req.employee.name,
    is_admin: !!req.employee.is_admin
  });
});

/** Reference data */
app.get("/api/customers", requireAuth(db), (req, res) => {
  const rows = db.prepare("SELECT id, name FROM customers ORDER BY name ASC").all();
  res.json(rows);
});

app.get("/api/employees", requireAdmin(db), (req, res) => {
  const rows = db.prepare("SELECT id, name, default_bill_rate, is_admin FROM employees ORDER BY name ASC").all();
  res.json(rows);
});

/** Time entries */
app.get("/api/time-entries", requireAuth(db), (req, res) => {
  const weekStart = String(req.query.week_start || weekStartYMD(new Date()));
  const { ordered } = weekDates(weekStart);
  const start = ordered[0].ymd;
  const end = ordered[6].ymd;

  const rows = db.prepare(`
    SELECT te.*, c.name as customer_name
    FROM time_entries te
    JOIN customers c ON c.id = te.customer_id
    WHERE te.employee_id = ?
      AND te.work_date >= ? AND te.work_date <= ?
    ORDER BY te.work_date ASC
  `).all(req.employee.id, start, end);

  res.json({ week_start: weekStart, days: ordered, entries: rows });
});

app.post("/api/time-entries", requireAuth(db), (req, res) => {
  const { customer_id, work_date, hours, notes } = req.body || {};
  if (!customer_id || !work_date || hours == null) return res.status(400).json({ error: "customer_id, work_date, hours required" });
  const now = new Date().toISOString();

  // Upsert per employee+customer+date (keeps UI simple)
  const existing = db.prepare(`
    SELECT id, status FROM time_entries
    WHERE employee_id = ? AND customer_id = ? AND work_date = ?
  `).get(req.employee.id, customer_id, work_date);

  if (existing && (existing.status === "SUBMITTED" || existing.status === "APPROVED")) {
    return res.status(409).json({ error: "Entry is locked (submitted/approved)" });
  }

  if (!existing) {
    db.prepare(`
      INSERT INTO time_entries
        (id, employee_id, customer_id, work_date, hours, notes, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, 'DRAFT', ?, ?)
    `).run(id("te_"), req.employee.id, customer_id, work_date, Number(hours), String(notes || ""), now, now);
  } else {
    db.prepare(`
      UPDATE time_entries
      SET hours = ?, notes = ?, updated_at = ?
      WHERE id = ?
    `).run(Number(hours), String(notes || ""), now, existing.id);
  }

  res.json({ ok: true });
});

app.post("/api/submit-week", requireAuth(db), (req, res) => {
  const weekStart = String(req.body?.week_start || weekStartYMD(new Date()));
  const { ordered } = weekDates(weekStart);
  const start = ordered[0].ymd;
  const end = ordered[6].ymd;

  db.prepare(`
    UPDATE time_entries
    SET status = 'SUBMITTED', updated_at = ?
    WHERE employee_id = ?
      AND work_date >= ? AND work_date <= ?
      AND status = 'DRAFT'
  `).run(new Date().toISOString(), req.employee.id, start, end);

  res.json({ ok: true, week_start: weekStart });
});

/** Admin approvals */
app.get("/api/approvals", requireAdmin(db), (req, res) => {
  const weekStart = String(req.query.week_start || weekStartYMD(new Date()));
  const { ordered } = weekDates(weekStart);
  const start = ordered[0].ymd;
  const end = ordered[6].ymd;

  const rows = db.prepare(`
    SELECT te.*, e.name as employee_name, c.name as customer_name
    FROM time_entries te
    JOIN employees e ON e.id = te.employee_id
    JOIN customers c ON c.id = te.customer_id
    WHERE te.work_date >= ? AND te.work_date <= ?
      AND te.status = 'SUBMITTED'
    ORDER BY te.work_date ASC, e.name ASC
  `).all(start, end);

  res.json({ week_start: weekStart, days: ordered, submitted: rows });
});

app.post("/api/approve", requireAdmin(db), (req, res) => {
  const ids = req.body?.ids;
  if (!Array.isArray(ids) || ids.length === 0) return res.status(400).json({ error: "ids[] required" });

  const stmt = db.prepare("UPDATE time_entries SET status='APPROVED', updated_at=? WHERE id=? AND status='SUBMITTED'");
  const now = new Date().toISOString();
  const tx = db.transaction(() => {
    for (const teId of ids) stmt.run(now, teId);
  });
  tx();

  res.json({ ok: true, approved: ids.length });
});

/** Voice: upload audio -> transcribe -> parse -> return proposed entries */
app.post("/api/voice/command", requireAuth(db), upload.single("audio"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: "audio file required" });
    const filePath = req.file.path;
    const originalName = req.file.originalname || "audio.webm";

    const customers = db.prepare("SELECT id, name FROM customers ORDER BY name ASC").all();
    const text = await transcribeAudio(filePath, originalName);
    const parsed = await parseVoiceCommand({ text, customers });

    res.json({ ok: true, transcript: text, parsed });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/** Exports */
app.get("/api/export/monthly", requireAdmin(db), async (req, res) => {
  try {
    const month = String(req.query.month || "").trim(); // YYYY-MM
    if (!/^\d{4}-\d{2}$/.test(month)) return res.status(400).json({ error: "month=YYYY-MM required" });
    const monthYmd = `${month}-01`;

    const wb = await buildMonthlyWorkbook({ db, monthYmd });
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.setHeader("Content-Disposition", `attachment; filename="Monthly Summary ${month}.xlsx"`);
    await wb.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

app.get("/api/export/invoice", requireAdmin(db), async (req, res) => {
  try {
    const customerId = String(req.query.customer_id || "");
    const start = String(req.query.start || "");
    const end = String(req.query.end || "");
    if (!customerId || !/^\d{4}-\d{2}-\d{2}$/.test(start) || !/^\d{4}-\d{2}-\d{2}$/.test(end)) {
      return res.status(400).json({ error: "customer_id, start=YYYY-MM-DD, end=YYYY-MM-DD required" });
    }

    const wb = await buildInvoiceWorkbook({ db, customerId, startYmd: start, endYmd: end });
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.setHeader("Content-Disposition", `attachment; filename="Invoice ${customerId} ${start} to ${end}.xlsx"`);
    await wb.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/** ============================================================
 *  NEW: Option A - Functional XLSX Pipeline Endpoints
 *  ============================================================ */

/**
 * Generate weekly XLSX exports (one per employee)
 * GET /api/admin/generate-week?week_start=YYYY-MM-DD
 */
app.get("/api/admin/generate-week", requireAdmin(db), async (req, res) => {
  try {
    const weekStart = String(req.query.week_start || weekStartYMD()).trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(weekStart)) {
      return res.status(400).json({ error: "week_start=YYYY-MM-DD required" });
    }

    const result = await generateWeeklyExports({ db, weekStart });
    res.json({
      ok: true,
      weekStart,
      outputDir: result.outputDir,
      files: result.files,
      totals: result.totals,
    });
  } catch (err) {
    console.error("[generate-week]", err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/**
 * Generate monthly payroll breakdown XLSX
 * GET /api/admin/generate-month?month=YYYY-MM
 */
app.get("/api/admin/generate-month", requireAdmin(db), async (req, res) => {
  try {
    const now = new Date();
    const defaultMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    const month = String(req.query.month || defaultMonth).trim();
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "month=YYYY-MM required" });
    }

    const result = await generateMonthlyExport({ db, month });
    res.json({
      ok: true,
      month,
      filepath: result.filepath,
      filename: result.filename,
      totals: result.totals,
    });
  } catch (err) {
    console.error("[generate-month]", err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/**
 * Close month: delete all time_entries for the specified month (retention policy)
 * POST /api/admin/close-month { month: "YYYY-MM", confirm: true }
 */
app.post("/api/admin/close-month", requireAdmin(db), async (req, res) => {
  try {
    const { month, confirm } = req.body;
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "month=YYYY-MM required" });
    }
    if (!confirm) {
      return res.status(400).json({ error: "confirm=true required to delete data" });
    }

    const monthStart = `${month}-01`;
    const [y, m] = month.split("-").map(Number);
    const nextMonth = m === 12 ? `${y + 1}-01-01` : `${y}-${String(m + 1).padStart(2, "0")}-01`;

    // Count entries before deletion
    const count = db.prepare(`
      SELECT COUNT(*) as cnt FROM time_entries
      WHERE work_date >= ? AND work_date < ?
    `).get(monthStart, nextMonth);

    // Delete entries
    const result = db.prepare(`
      DELETE FROM time_entries
      WHERE work_date >= ? AND work_date < ?
    `).run(monthStart, nextMonth);

    console.log(`[close-month] Deleted ${result.changes} entries for ${month}`);

    res.json({
      ok: true,
      month,
      deletedCount: result.changes,
      message: `Closed month ${month}: ${result.changes} entries deleted`,
    });
  } catch (err) {
    console.error("[close-month]", err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/**
 * Get holidays for a year or date range
 * GET /api/holidays?year=2026  OR  /api/holidays?start=YYYY-MM-DD&end=YYYY-MM-DD
 */
app.get("/api/holidays", (req, res) => {
  try {
    const year = req.query.year;
    const start = req.query.start;
    const end = req.query.end;

    if (year) {
      const holidays = getHolidaysForYear(parseInt(year, 10));
      return res.json({ ok: true, year: parseInt(year, 10), holidays });
    }

    if (start && end) {
      const holidays = getHolidaysInRange(start, end);
      return res.json({ ok: true, start, end, holidays });
    }

    // Default: current year
    const currentYear = new Date().getFullYear();
    const holidays = getHolidaysForYear(currentYear);
    res.json({ ok: true, year: currentYear, holidays });
  } catch (err) {
    console.error("[holidays]", err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/**
 * Auto-create customer if not found (for client confirmation flow)
 * POST /api/customers/find-or-create { name: string, address?: string }
 */
app.post("/api/customers/find-or-create", requireAuth(db), (req, res) => {
  try {
    const { name, address } = req.body;
    if (!name?.trim()) {
      return res.status(400).json({ error: "name required" });
    }

    const trimmedName = name.trim();
    
    // Try to find existing customer by name (case-insensitive)
    let customer = db.prepare(`
      SELECT * FROM customers WHERE LOWER(name) = LOWER(?)
    `).get(trimmedName);

    if (!customer) {
      // Create new customer
      const newId = id("cust_");
      db.prepare(`
        INSERT INTO customers (id, name, created_at)
        VALUES (?, ?, datetime('now'))
      `).run(newId, trimmedName);
      
      customer = db.prepare("SELECT * FROM customers WHERE id = ?").get(newId);
      console.log(`[find-or-create] Created new customer: ${trimmedName}`);
    }

    res.json({ ok: true, customer, created: !customer });
  } catch (err) {
    console.error("[find-or-create]", err);
    res.status(500).json({ error: String(err?.message || err) });
  }
});

/** SPA fallbacks */
app.get("/", (req, res) => res.sendFile(path.resolve("public/index.html")));
app.get("/app", (req, res) => res.sendFile(path.resolve("public/app.html")));
app.get("/admin", (req, res) => res.sendFile(path.resolve("public/admin.html")));

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
  console.log(`Labor Timekeeper running on http://localhost:${port}`);
});

--o--
=== package.json ===
{
  "name": "labor-timekeeper",
  "version": "0.2.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node --watch server.js",
    "start": "node server.js",
    "seed": "node scripts/seed.js",
    "simulate": "node scripts/simulate.js",
    "export:monthly": "node scripts/export_monthly.js",
    "test": "npx playwright test",
    "test:ui": "npx playwright test --ui",
    "test:headed": "npx playwright test --headed"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "better-sqlite3": "^11.6.0",
    "cookie-parser": "^1.4.6",
    "date-fns": "^3.6.0",
    "date-fns-tz": "^3.1.3",
    "dotenv": "^16.4.5",
    "exceljs": "^4.4.0",
    "express": "^4.19.2",
    "fuse.js": "^7.0.0",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nanoid": "^5.0.7",
    "openai": "^4.56.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@playwright/test": "^1.57.0"
  }
}

--o--
=== playwright.config.cjs ===
// @ts-check
const { defineConfig } = require('@playwright/test');

module.exports = defineConfig({
  testDir: './tests',
  testMatch: '**/*.spec.cjs',
  fullyParallel: false,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: 1,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { browserName: 'chromium' },
    },
  ],
  webServer: {
    command: 'npm run start',
    url: 'http://localhost:3000',
    reuseExistingServer: true,
  },
});

--o--
=== lib/auth.js ===
import bcrypt from "bcryptjs";
import { id } from "./db.js";

const COOKIE_NAME = "sid";

export function cookieName() {
  return COOKIE_NAME;
}

export function hashPin(pin) {
  return bcrypt.hashSync(String(pin), 10);
}

export function verifyPin(pin, hash) {
  return bcrypt.compareSync(String(pin), hash);
}

export function createSession(db, employeeId) {
  const sid = id("sess_");
  const now = new Date();
  const ttlHours = Number(process.env.SESSION_TTL_HOURS ?? 168);
  const expires = new Date(now.getTime() + ttlHours * 60 * 60 * 1000);
  db.prepare(
    "INSERT INTO sessions (id, employee_id, created_at, expires_at) VALUES (?, ?, ?, ?)"
  ).run(sid, employeeId, now.toISOString(), expires.toISOString());
  return { sid, expires };
}

export function destroySession(db, sid) {
  db.prepare("DELETE FROM sessions WHERE id = ?").run(sid);
}

export function getSession(db, sid) {
  if (!sid) return null;
  const row = db.prepare("SELECT * FROM sessions WHERE id = ?").get(sid);
  if (!row) return null;
  if (new Date(row.expires_at).getTime() < Date.now()) {
    destroySession(db, sid);
    return null;
  }
  return row;
}

export function requireAuth(db) {
  return (req, res, next) => {
    const sid = req.cookies?.[COOKIE_NAME];
    const sess = getSession(db, sid);
    if (!sess) return res.status(401).json({ error: "Not authenticated" });
    const emp = db
      .prepare("SELECT id, name, default_bill_rate, default_pay_rate, is_admin, aliases_json FROM employees WHERE id = ?")
      .get(sess.employee_id);
    if (!emp) return res.status(401).json({ error: "Invalid session" });
    req.employee = emp;
    req.session = sess;
    next();
  };
}

export function requireAdmin(db) {
  const auth = requireAuth(db);
  return (req, res, next) => {
    auth(req, res, () => {
      if (!req.employee?.is_admin) return res.status(403).json({ error: "Admin only" });
      next();
    });
  };
}

--o--
=== lib/billing.js ===
export function getBillRate(db, employeeId, customerId) {
  const row = db.prepare(
    "SELECT bill_rate FROM rate_overrides WHERE employee_id = ? AND customer_id = ?"
  ).get(employeeId, customerId);
  if (row?.bill_rate != null) return Number(row.bill_rate);
  const emp = db.prepare("SELECT default_bill_rate FROM employees WHERE id = ?").get(employeeId);
  return Number(emp?.default_bill_rate ?? 0);
}

--o--
=== lib/classification.js ===
/**
 * Employee Classification Utilities
 * Splits employees into admin (salaried) vs hourly categories
 * Handles overtime calculation for hourly employees
 */

// Admin employees (salaried, no OT)
const ADMIN_NAMES = ["Chris Jacobi", "Chris Z", "Chris Zavesky"];

/**
 * Check if employee is classified as admin/salaried
 * @param {string} employeeName - Employee name
 * @returns {boolean}
 */
export function isAdmin(employeeName) {
  const normalized = employeeName.toLowerCase().trim();
  return ADMIN_NAMES.some((name) => normalized === name.toLowerCase());
}

/**
 * Get employee category
 * @param {string} employeeName - Employee name
 * @returns {"admin" | "hourly"}
 */
export function getEmployeeCategory(employeeName) {
  return isAdmin(employeeName) ? "admin" : "hourly";
}

/**
 * Calculate pay with overtime for hourly employees
 * OT applies after 40 hours/week at 1.5x rate
 * @param {number} weeklyHours - Total hours for the week
 * @param {number} rate - Base hourly rate
 * @param {string} category - "admin" or "hourly"
 * @returns {{regularHours: number, otHours: number, regularPay: number, otPay: number, totalPay: number}}
 */
export function calculatePayWithOT(weeklyHours, rate, category) {
  // Admins: no overtime calculation, straight pay
  if (category === "admin") {
    return {
      regularHours: weeklyHours,
      otHours: 0,
      regularPay: round2(weeklyHours * rate),
      otPay: 0,
      totalPay: round2(weeklyHours * rate),
    };
  }

  // Hourly: OT after 40 hours at 1.5x
  const OT_THRESHOLD = 40;
  const OT_MULTIPLIER = 1.5;

  const regularHours = Math.min(weeklyHours, OT_THRESHOLD);
  const otHours = Math.max(0, weeklyHours - OT_THRESHOLD);
  const regularPay = round2(regularHours * rate);
  const otPay = round2(otHours * rate * OT_MULTIPLIER);
  const totalPay = round2(regularPay + otPay);

  return { regularHours, otHours, regularPay, otPay, totalPay };
}

/**
 * Split entries into regular and overtime portions
 * For weekly breakdown by day
 * @param {Array} entries - Array of {hours, rate} objects sorted by date
 * @param {string} category - "admin" or "hourly"
 * @returns {Array} Entries with added type field ("Regular" or "OT")
 */
export function splitEntriesWithOT(entries, category) {
  if (category === "admin") {
    // Admin: all regular
    return entries.map((e) => ({ ...e, type: "Regular" }));
  }

  // Hourly: track cumulative hours, mark OT after 40
  const OT_THRESHOLD = 40;
  let cumulative = 0;
  const result = [];

  for (const entry of entries) {
    const hours = Number(entry.hours);
    const beforeThis = cumulative;
    cumulative += hours;

    if (beforeThis >= OT_THRESHOLD) {
      // All OT
      result.push({ ...entry, type: "OT", hours });
    } else if (cumulative <= OT_THRESHOLD) {
      // All regular
      result.push({ ...entry, type: "Regular", hours });
    } else {
      // Split: some regular, some OT
      const regularPortion = OT_THRESHOLD - beforeThis;
      const otPortion = hours - regularPortion;
      if (regularPortion > 0) {
        result.push({ ...entry, type: "Regular", hours: regularPortion });
      }
      if (otPortion > 0) {
        result.push({ ...entry, type: "OT", hours: otPortion });
      }
    }
  }

  return result;
}

function round2(n) {
  return Math.round(Number(n) * 100) / 100;
}

--o--
=== lib/db.js ===
import fs from "fs";
import path from "path";
import Database from "better-sqlite3";
import { nanoid } from "nanoid";

const DEFAULT_DB_PATH = "./data/app.db";

function ensureDir(p) {
  const dir = path.dirname(p);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

export function openDb() {
  const dbPath = process.env.DATABASE_PATH || DEFAULT_DB_PATH;
  ensureDir(dbPath);
  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  migrate(db);
  return db;
}

function migrate(db) {
  db.exec(`
CREATE TABLE IF NOT EXISTS employees (
  id TEXT PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  pin_hash TEXT NOT NULL,
  default_bill_rate REAL NOT NULL DEFAULT 0,
  default_pay_rate REAL NOT NULL DEFAULT 0,
  is_admin INTEGER NOT NULL DEFAULT 0,
  aliases_json TEXT NOT NULL DEFAULT '[]',
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS customers (
  id TEXT PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS rate_overrides (
  id TEXT PRIMARY KEY,
  employee_id TEXT NOT NULL,
  customer_id TEXT NOT NULL,
  bill_rate REAL NOT NULL,
  created_at TEXT NOT NULL,
  UNIQUE(employee_id, customer_id),
  FOREIGN KEY(employee_id) REFERENCES employees(id),
  FOREIGN KEY(customer_id) REFERENCES customers(id)
);

CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  employee_id TEXT NOT NULL,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  FOREIGN KEY(employee_id) REFERENCES employees(id)
);

CREATE TABLE IF NOT EXISTS time_entries (
  id TEXT PRIMARY KEY,
  employee_id TEXT NOT NULL,
  customer_id TEXT NOT NULL,
  work_date TEXT NOT NULL, -- YYYY-MM-DD (America/New_York)
  hours REAL NOT NULL,
  notes TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT 'DRAFT', -- DRAFT | SUBMITTED | APPROVED
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY(employee_id) REFERENCES employees(id),
  FOREIGN KEY(customer_id) REFERENCES customers(id)
);

CREATE INDEX IF NOT EXISTS idx_time_entries_emp_date ON time_entries(employee_id, work_date);
CREATE INDEX IF NOT EXISTS idx_time_entries_cust_date ON time_entries(customer_id, work_date);
  `);
}

export function id(prefix = "") {
  return prefix + nanoid(16);
}

--o--
=== lib/export_excel.js ===
import ExcelJS from "exceljs";
import { getBillRate } from "./billing.js";

export async function buildMonthlyWorkbook({ db, monthYmd }) {
  // monthYmd: 'YYYY-MM-01' typically
  const workbook = new ExcelJS.Workbook();
  const ws = workbook.addWorksheet("Monthly Summary");

  // Pull approved+submitted entries for the month (you can tighten to APPROVED only if desired)
  const rows = db.prepare(`
    SELECT te.*, e.name as employee_name, c.name as customer_name
    FROM time_entries te
    JOIN employees e ON e.id = te.employee_id
    JOIN customers c ON c.id = te.customer_id
    WHERE te.work_date >= ? AND te.work_date < ?
      AND te.status IN ('SUBMITTED','APPROVED')
  `).all(monthYmd, nextMonth(monthYmd));

  const employees = [...new Set(rows.map(r => r.employee_name))].sort((a,b)=>a.localeCompare(b));
  // Header
  const header = ["Client"];
  for (const emp of employees) {
    header.push(`${emp} Hours`, `${emp} Rate`, `${emp} Amount`);
  }
  ws.addRow(header);

  // Group by customer then employee
  const byCustomer = new Map();
  for (const r of rows) {
    if (!byCustomer.has(r.customer_id)) byCustomer.set(r.customer_id, { name: r.customer_name, byEmp: new Map() });
    const cust = byCustomer.get(r.customer_id);
    if (!cust.byEmp.has(r.employee_id)) cust.byEmp.set(r.employee_id, { hours: 0, employee_name: r.employee_name, employee_id: r.employee_id });
    cust.byEmp.get(r.employee_id).hours += Number(r.hours);
  }

  for (const [customerId, cust] of [...byCustomer.entries()].sort((a,b)=>a[1].name.localeCompare(b[1].name))) {
    const row = [cust.name];
    for (const empName of employees) {
      // find employeeId for this empName if present
      const empRows = rows.find(r => r.employee_name === empName);
      const empId = empRows?.employee_id;
      const empHours = [...cust.byEmp.values()].find(v => v.employee_name === empName)?.hours || 0;
      const rate = empId ? getBillRate(db, empId, customerId) : 0;
      row.push(round2(empHours), rate, round2(empHours * rate));
    }
    ws.addRow(row);
  }

  ws.columns.forEach(col => { col.width = Math.max(12, String(col.header ?? '').length + 2); });
  ws.getRow(1).font = { bold: true };

  return workbook;
}

export async function buildInvoiceWorkbook({ db, customerId, startYmd, endYmd }) {
  const workbook = new ExcelJS.Workbook();
  const mat = workbook.addWorksheet("MATERIAL");
  const labor = workbook.addWorksheet("LABOR");
  const calc = workbook.addWorksheet("CALCULATOR");

  const cust = db.prepare("SELECT name FROM customers WHERE id = ?").get(customerId);
  const custName = cust?.name || "Customer";

  // MATERIAL placeholder
  mat.addRow(["Date","Item","Qty","Unit Cost","Total"]);
  mat.getRow(1).font = { bold: true };

  // LABOR
  labor.addRow(["Date","Employee","Rate","Hours","Total"]);
  labor.getRow(1).font = { bold: true };

  const rows = db.prepare(`
    SELECT te.work_date, te.hours, te.notes, e.id as employee_id, e.name as employee_name
    FROM time_entries te
    JOIN employees e ON e.id = te.employee_id
    WHERE te.customer_id = ?
      AND te.work_date >= ? AND te.work_date <= ?
      AND te.status IN ('SUBMITTED','APPROVED')
    ORDER BY te.work_date ASC
  `).all(customerId, startYmd, endYmd);

  let laborTotal = 0;
  for (const r of rows) {
    const rate = getBillRate(db, r.employee_id, customerId);
    const total = Number(r.hours) * rate;
    laborTotal += total;
    labor.addRow([r.work_date, r.employee_name, rate, Number(r.hours), round2(total)]);
  }

  // CALCULATOR (simple)
  const materialsTotal = 0;
  calc.addRow([materialsTotal, "Materials Amount", "", custName.toUpperCase()]);
  calc.addRow([round2(laborTotal), "Labor Amount", "", ""]);
  calc.addRow([round2(materialsTotal + laborTotal), "Subtotal", "", ""]);
  calc.addRow([round2((materialsTotal + laborTotal) * 0.1), "0.1", "", ""]);
  calc.addRow([round2((materialsTotal + laborTotal) * 1.1), "Subtotal", "", ""]);
  calc.addRow([round2((materialsTotal + laborTotal) * 1.1 * 0.05), "0.05", "", ""]);
  calc.addRow([round2((materialsTotal + laborTotal) * 1.1 * 1.05), "Grand Total", "", ""]);

  return workbook;
}

function nextMonth(ymd) {
  const [y,m,_] = ymd.split("-").map(Number);
  let ny = y, nm = m + 1;
  if (nm === 13) { nm = 1; ny += 1; }
  return `${ny}-${String(nm).padStart(2,"0")}-01`;
}

function round2(n) {
  return Math.round(Number(n) * 100) / 100;
}

--o--
=== lib/holidays.js ===
/**
 * US Federal Holidays for payroll auto-population
 * Returns holidays for a given year
 */

// Memorial Day: last Monday of May
function getMemorialDay(year) {
  const lastDayOfMay = new Date(year, 4, 31);
  const dayOfWeek = lastDayOfMay.getDay();
  const diff = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  return new Date(year, 4, 31 - diff);
}

// Labor Day: first Monday of September
function getLaborDay(year) {
  const firstOfSept = new Date(year, 8, 1);
  const dayOfWeek = firstOfSept.getDay();
  const diff = dayOfWeek === 0 ? 1 : dayOfWeek === 1 ? 0 : 8 - dayOfWeek;
  return new Date(year, 8, 1 + diff);
}

// Thanksgiving: fourth Thursday of November
function getThanksgiving(year) {
  const firstOfNov = new Date(year, 10, 1);
  const dayOfWeek = firstOfNov.getDay();
  const firstThursday = dayOfWeek <= 4 ? 4 - dayOfWeek + 1 : 11 - dayOfWeek + 1;
  return new Date(year, 10, firstThursday + 21);
}

function formatYmd(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

/**
 * Get all US federal holidays for a given year
 * @param {number} year - The year to get holidays for
 * @returns {Array<{date: string, name: string}>} Array of holiday objects
 */
export function getHolidaysForYear(year) {
  return [
    { date: `${year}-01-01`, name: "New Year's Day" },
    { date: formatYmd(getMemorialDay(year)), name: "Memorial Day" },
    { date: `${year}-07-04`, name: "Independence Day" },
    { date: formatYmd(getLaborDay(year)), name: "Labor Day" },
    { date: formatYmd(getThanksgiving(year)), name: "Thanksgiving" },
    { date: `${year}-12-25`, name: "Christmas" },
  ];
}

/**
 * Check if a date is a US federal holiday
 * @param {string} ymd - Date in YYYY-MM-DD format
 * @returns {{isHoliday: boolean, name: string|null}}
 */
export function isHoliday(ymd) {
  const year = parseInt(ymd.split("-")[0], 10);
  const holidays = getHolidaysForYear(year);
  const found = holidays.find((h) => h.date === ymd);
  return { isHoliday: !!found, name: found?.name || null };
}

/**
 * Get holidays within a date range
 * @param {string} startYmd - Start date YYYY-MM-DD
 * @param {string} endYmd - End date YYYY-MM-DD
 * @returns {Array<{date: string, name: string}>}
 */
export function getHolidaysInRange(startYmd, endYmd) {
  const startYear = parseInt(startYmd.split("-")[0], 10);
  const endYear = parseInt(endYmd.split("-")[0], 10);
  const allHolidays = [];
  
  for (let y = startYear; y <= endYear; y++) {
    allHolidays.push(...getHolidaysForYear(y));
  }
  
  return allHolidays.filter((h) => h.date >= startYmd && h.date <= endYmd);
}

--o--
=== lib/openai.js ===
import OpenAI from "openai";

export function getOpenAI() {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) return null;
  return new OpenAI({ apiKey });
}

--o--
=== lib/time.js ===
import { addDays, startOfWeek, format } from "date-fns";
import { toZonedTime, formatInTimeZone } from "date-fns-tz";

export const TZ = process.env.TIMEZONE || "America/New_York";

export function todayYMD() {
  const now = new Date();
  return formatInTimeZone(now, TZ, "yyyy-MM-dd");
}

export function weekStartYMD(date = new Date()) {
  const weekStartsOn = Number(process.env.PAYROLL_WEEK_START ?? 1); // Monday default
  // Use zoned time for consistent payroll weeks
  const zoned = toZonedTime(date, TZ);
  const start = startOfWeek(zoned, { weekStartsOn });
  return format(start, "yyyy-MM-dd");
}

export function weekDates(weekStart) {
  // weekStart is YYYY-MM-DD
  const [y,m,d] = weekStart.split("-").map(Number);
  const start = new Date(Date.UTC(y, m-1, d, 12, 0, 0)); // noon UTC avoids DST edge
  const zonedStart = toZonedTime(start, TZ);
  const map = {};
  const keys = ["sun","mon","tue","wed","thu","fri","sat"];
  // Determine actual weekday order relative to configured start
  const weekStartsOn = Number(process.env.PAYROLL_WEEK_START ?? 1);
  // Build 7 days starting at weekStart
  for (let i=0;i<7;i++){
    const day = addDays(zonedStart, i);
    const ymd = format(day, "yyyy-MM-dd");
    const weekdayIdx = day.getDay(); // 0 Sunday ...
    map[keys[weekdayIdx]] = ymd;
  }
  // Also provide ordered list starting at weekStart
  const ordered = [];
  for (let i=0;i<7;i++){
    const day = addDays(zonedStart, i);
    ordered.push({
      ymd: format(day, "yyyy-MM-dd"),
      dow: ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][day.getDay()]
    });
  }
  return { map, ordered, weekStartsOn };
}

export function ymdToDate(ymd){
  const [y,m,d] = ymd.split("-").map(Number);
  // Return a Date representing noon UTC for stability
  return new Date(Date.UTC(y, m-1, d, 12, 0, 0));
}

--o--
=== lib/voice.js ===
import fs from "fs";
import { z } from "zod";
import { getOpenAI } from "./openai.js";
import { weekStartYMD, weekDates, todayYMD, TZ } from "./time.js";
import Fuse from "fuse.js";

// Schema for parsing a "voice command" into entries
export const VoiceParseSchema = z.object({
  entries: z.array(
    z.object({
      customer: z.string(),
      day: z.enum(["mon","tue","wed","thu","fri","sat","sun"]).nullable().optional(),
      // allow direct date too (YYYY-MM-DD)
      work_date: z.string().nullable().optional(),
      hours: z.number(),
      notes: z.string().nullable().optional()
    })
  )
});

export async function transcribeAudio(tempFilePath, originalName = "audio.webm") {
  const openai = getOpenAI();
  if (!openai) throw new Error("OPENAI_API_KEY is not set");
  
  // Rename temp file to have proper extension for OpenAI
  const ext = originalName.includes('.') ? originalName.split('.').pop() : 'webm';
  const newPath = `${tempFilePath}.${ext}`;
  fs.renameSync(tempFilePath, newPath);
  
  const transcription = await openai.audio.transcriptions.create({
    file: fs.createReadStream(newPath),
    model: "whisper-1",
    response_format: "json"
  });
  
  // Clean up renamed file
  fs.unlinkSync(newPath);
  
  return transcription.text || "";
}

export async function parseVoiceCommand({ text, customers, referenceDate }) {
  const openai = getOpenAI();
  if (!openai) throw new Error("OPENAI_API_KEY is not set");

  const nowYmd = todayYMD();
  const weekStart = weekStartYMD(referenceDate ?? new Date());
  const { map, ordered } = weekDates(weekStart);
  const customerList = customers.map(c => c.name);

  // Keep list compact; if huge, you'd do server-side retrieval instead
  const system = [
    "You extract structured time entries from short, messy voice commands.",
    "Return JSON that matches the schema exactly.",
    "Rules:",
    "- Interpret weekday words (Mon/Tue/.../Friday/etc) as days in the CURRENT payroll week.",
    `- Payroll week starts on ${weekStart}.`,
    `- Today (America/New_York) is ${nowYmd}.`,
    "- If day is omitted, assume the user means today.",
    "- Hours are numeric (allow decimals like 7.5).",
    "- Customer must be chosen from the provided customer list; if not sure, pick the closest match.",
    "- Do not invent employees or rates; only output what you can parse from the command.",
    "",
    "Customer list:",
    customerList.join(" | ")
  ].join("\n");

  // Use Structured Outputs (Zod) via responses.parse
  // Ref: Structured outputs guide
  const response = await openai.responses.parse({
    model: "gpt-4o-mini",
    input: [
      { role: "system", content: system },
      { role: "user", content: `Command: ${text}\n\nOutput JSON only.` }
    ],
    text: {
      format: {
        type: "json_schema",
        name: "voice_time_entries",
        strict: true,
        schema: {
          type: "object",
          additionalProperties: false,
          required: ["entries"],
          properties: {
            entries: {
              type: "array",
              items: {
                type: "object",
                additionalProperties: false,
                required: ["customer", "day", "work_date", "hours", "notes"],
                properties: {
                  customer: { type: "string" },
                  day: { type: ["string", "null"], enum: ["mon","tue","wed","thu","fri","sat","sun", null] },
                  work_date: { type: ["string", "null"] },
                  hours: { type: "number" },
                  notes: { type: ["string", "null"] }
                }
              }
            }
          }
        }
      }
    }
  });

  const parsed = response.output_parsed;
  const safe = VoiceParseSchema.parse(parsed);

  // Resolve customer names robustly with Fuse, then map weekday->date.
  const fuse = new Fuse(customers, { keys: ["name"], threshold: 0.35 });

  const resolved = safe.entries.map(e => {
    const match = fuse.search(e.customer)[0]?.item;
    const customer = match || customers.find(c => c.name.toLowerCase() === e.customer.toLowerCase()) || null;

    let workDate = e.work_date;
    if (!workDate) {
      if (e.day) {
        workDate = map[e.day] || map["mon"];
      } else {
        // If no day specified, assume today (in America/New_York) but keep it inside the current week.
        const t = todayYMD();
        const inWeek = Object.values(map).includes(t);
        workDate = inWeek ? t : (map["mon"] || t);
      }
    }
    return {
      ...e,
      customer_id: customer?.id || null,
      customer_name: customer?.name || e.customer,
      work_date: workDate
    };
  });

  return { week_start: weekStart, ordered_days: ordered, entries: resolved };
}

function inferDayFromText(text) {
  const t = text.toLowerCase();
  if (t.includes("monday") || t.includes("mon")) return "mon";
  if (t.includes("tuesday") || t.includes("tue")) return "tue";
  if (t.includes("wednesday") || t.includes("wed")) return "wed";
  if (t.includes("thursday") || t.includes("thu")) return "thu";
  if (t.includes("friday") || t.includes("fri")) return "fri";
  if (t.includes("saturday") || t.includes("sat")) return "sat";
  if (t.includes("sunday") || t.includes("sun")) return "sun";
  // default "today" handled elsewhere; here default mon
  return "mon";
}

--o--
=== lib/export/generateWeekly.js ===
/**
 * Weekly XLSX Export Generator
 * Generates 1 workbook per employee per week
 * Filename: <EmployeeName>_<YYYY-MM-DD>.xlsx
 * Columns: Date, Client, Hours, Type (Regular|OT|PTO|Holiday), Rate, Total
 */

import fs from "fs";
import path from "path";
import ExcelJS from "exceljs";
import { getBillRate } from "../billing.js";
import { getEmployeeCategory, splitEntriesWithOT, calculatePayWithOT } from "../classification.js";
import { isHoliday } from "../holidays.js";

/**
 * Generate weekly XLSX files for all employees with approved entries
 * @param {Object} options
 * @param {Database} options.db - SQLite database instance
 * @param {string} options.weekStart - Week start date YYYY-MM-DD
 * @returns {Promise<{files: Array, totals: Object}>}
 */
export async function generateWeeklyExports({ db, weekStart }) {
  // Calculate week end (7 days from start)
  const [y, m, d] = weekStart.split("-").map(Number);
  const startDate = new Date(y, m - 1, d);
  const endDate = new Date(startDate);
  endDate.setDate(endDate.getDate() + 6);
  const weekEnd = formatYmd(endDate);

  // Create output directory: /exports/<YYYY-MM>/<weekStart>/
  const monthDir = weekStart.slice(0, 7);
  const outputDir = path.resolve(`./exports/${monthDir}/${weekStart}`);
  ensureDir(outputDir);

  // Query all approved entries for the week, grouped by employee
  const entries = db.prepare(`
    SELECT te.*, e.name as employee_name, e.default_bill_rate, c.name as customer_name
    FROM time_entries te
    JOIN employees e ON e.id = te.employee_id
    JOIN customers c ON c.id = te.customer_id
    WHERE te.work_date >= ? AND te.work_date <= ?
      AND te.status = 'APPROVED'
    ORDER BY te.employee_id, te.work_date ASC
  `).all(weekStart, weekEnd);

  // Group by employee
  const byEmployee = new Map();
  for (const row of entries) {
    if (!byEmployee.has(row.employee_id)) {
      byEmployee.set(row.employee_id, {
        id: row.employee_id,
        name: row.employee_name,
        entries: [],
      });
    }
    byEmployee.get(row.employee_id).entries.push(row);
  }

  const files = [];
  const totals = {
    employees: 0,
    totalHours: 0,
    totalRegular: 0,
    totalOT: 0,
    totalAmount: 0,
  };

  // Generate one workbook per employee
  for (const [empId, emp] of byEmployee) {
    const category = getEmployeeCategory(emp.name);
    const workbook = new ExcelJS.Workbook();
    const ws = workbook.addWorksheet("Weekly Timesheet");

    // Header row
    ws.addRow(["Date", "Client", "Hours", "Type", "Rate", "Total"]);
    ws.getRow(1).font = { bold: true };
    ws.getRow(1).fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FFE0E0E0" },
    };

    // Build entries with rate lookup and type assignment
    const enrichedEntries = emp.entries.map((e) => {
      const rate = getBillRate(db, e.employee_id, e.customer_id);
      const holiday = isHoliday(e.work_date);
      return {
        ...e,
        rate,
        holidayName: holiday.name,
      };
    });

    // Split entries for OT calculation (hourly employees)
    const processedEntries = splitEntriesWithOT(enrichedEntries, category);

    // Calculate totals for this employee
    let empTotalHours = 0;
    let empRegularHours = 0;
    let empOTHours = 0;
    let empTotalAmount = 0;

    // Add data rows
    for (const entry of processedEntries) {
      const hours = Number(entry.hours);
      const rate = entry.rate;
      
      // Determine type: check for holiday first, then regular/OT
      let type = entry.type || "Regular";
      if (entry.holidayName) {
        type = "Holiday";
      }
      // Check notes for PTO indicator
      if (entry.notes?.toLowerCase().includes("pto")) {
        type = "PTO";
      }

      const otMultiplier = type === "OT" ? 1.5 : 1;
      const total = round2(hours * rate * otMultiplier);

      ws.addRow([
        entry.work_date,
        entry.customer_name,
        hours,
        type,
        rate,
        total,
      ]);

      empTotalHours += hours;
      if (type === "OT") {
        empOTHours += hours;
      } else {
        empRegularHours += hours;
      }
      empTotalAmount += total;
    }

    // Add subtotal row
    ws.addRow([]);
    const subtotalRow = ws.addRow([
      "SUBTOTAL",
      "",
      round2(empTotalHours),
      `Reg: ${round2(empRegularHours)} / OT: ${round2(empOTHours)}`,
      "",
      round2(empTotalAmount),
    ]);
    subtotalRow.font = { bold: true };
    subtotalRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FFFFE0B0" },
    };

    // Category info row
    ws.addRow([`Category: ${category.toUpperCase()}`, "", "", "", "", ""]);

    // Format columns
    ws.columns = [
      { width: 12 },  // Date
      { width: 25 },  // Client
      { width: 8 },   // Hours
      { width: 10 },  // Type
      { width: 8 },   // Rate
      { width: 12 },  // Total
    ];

    // Format currency columns
    ws.getColumn(5).numFmt = '"$"#,##0.00';
    ws.getColumn(6).numFmt = '"$"#,##0.00';

    // Save file
    const safeName = emp.name.replace(/[^a-zA-Z0-9]/g, "_");
    const filename = `${safeName}_${weekStart}.xlsx`;
    const filepath = path.join(outputDir, filename);
    await workbook.xlsx.writeFile(filepath);

    files.push({
      employee: emp.name,
      category,
      filename,
      filepath,
      hours: empTotalHours,
      regularHours: empRegularHours,
      otHours: empOTHours,
      amount: empTotalAmount,
    });

    // Update totals
    totals.employees++;
    totals.totalHours += empTotalHours;
    totals.totalRegular += empRegularHours;
    totals.totalOT += empOTHours;
    totals.totalAmount += empTotalAmount;
  }

  // Round final totals
  totals.totalHours = round2(totals.totalHours);
  totals.totalRegular = round2(totals.totalRegular);
  totals.totalOT = round2(totals.totalOT);
  totals.totalAmount = round2(totals.totalAmount);

  console.log(`[generateWeekly] Week ${weekStart}: ${files.length} employee files generated`);
  console.log(`[generateWeekly] Totals: ${totals.totalHours}hrs (${totals.totalRegular} reg + ${totals.totalOT} OT) = $${totals.totalAmount}`);

  return { files, totals, outputDir };
}

// Helpers
function formatYmd(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function round2(n) {
  return Math.round(Number(n) * 100) / 100;
}

--o--
=== lib/export/generateMonthly.js ===
/**
 * Monthly Payroll Breakdown XLSX Generator
 * Generates 1 consolidated workbook for the entire month
 * Filename: Payroll_Breakdown_<YYYY-MM>.xlsx
 * Columns: Client, then for each Employee: Hours, Rate, Amount Billed
 */

import fs from "fs";
import path from "path";
import ExcelJS from "exceljs";
import { getBillRate } from "../billing.js";
import { getEmployeeCategory, calculatePayWithOT } from "../classification.js";

/**
 * Generate monthly payroll breakdown XLSX
 * @param {Object} options
 * @param {Database} options.db - SQLite database instance
 * @param {string} options.month - Month in YYYY-MM format
 * @returns {Promise<{filepath: string, totals: Object}>}
 */
export async function generateMonthlyExport({ db, month }) {
  // Calculate date range for the month
  const monthStart = `${month}-01`;
  const [y, m] = month.split("-").map(Number);
  const nextMonth = m === 12 ? `${y + 1}-01-01` : `${y}-${String(m + 1).padStart(2, "0")}-01`;

  // Create output directory
  const outputDir = path.resolve(`./exports/${month}`);
  ensureDir(outputDir);

  // Query all approved entries for the month
  const entries = db.prepare(`
    SELECT te.*, e.name as employee_name, e.id as emp_id, c.name as customer_name, c.id as cust_id
    FROM time_entries te
    JOIN employees e ON e.id = te.employee_id
    JOIN customers c ON c.id = te.customer_id
    WHERE te.work_date >= ? AND te.work_date < ?
      AND te.status = 'APPROVED'
    ORDER BY c.name ASC, e.name ASC
  `).all(monthStart, nextMonth);

  // Get unique employees and customers
  const employees = [...new Set(entries.map((r) => r.employee_name))].sort();
  const employeeIds = new Map(entries.map((r) => [r.employee_name, r.emp_id]));

  // Aggregate by customer + employee
  const byCustomer = new Map();
  for (const row of entries) {
    if (!byCustomer.has(row.cust_id)) {
      byCustomer.set(row.cust_id, {
        id: row.cust_id,
        name: row.customer_name,
        byEmployee: new Map(),
      });
    }
    const cust = byCustomer.get(row.cust_id);
    if (!cust.byEmployee.has(row.employee_name)) {
      cust.byEmployee.set(row.employee_name, {
        hours: 0,
        empId: row.emp_id,
      });
    }
    cust.byEmployee.get(row.employee_name).hours += Number(row.hours);
  }

  // Create workbook
  const workbook = new ExcelJS.Workbook();
  const ws = workbook.addWorksheet("Payroll Breakdown");

  // Build header row: Client | Emp1 Hours | Emp1 Rate | Emp1 Amount | Emp2 Hours | ...
  const header = ["Client"];
  for (const empName of employees) {
    header.push(`${empName} Hours`, `${empName} Rate`, `${empName} Amount`);
  }
  header.push("Row Total");
  ws.addRow(header);

  // Style header
  const headerRow = ws.getRow(1);
  headerRow.font = { bold: true };
  headerRow.fill = {
    type: "pattern",
    pattern: "solid",
    fgColor: { argb: "FF4472C4" },
  };
  headerRow.font = { bold: true, color: { argb: "FFFFFFFF" } };

  // Track totals per employee
  const employeeTotals = new Map();
  for (const empName of employees) {
    employeeTotals.set(empName, { hours: 0, amount: 0 });
  }
  let grandTotal = 0;

  // Data rows - one per customer
  const sortedCustomers = [...byCustomer.values()].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  for (const cust of sortedCustomers) {
    const row = [cust.name];
    let rowTotal = 0;

    for (const empName of employees) {
      const empData = cust.byEmployee.get(empName);
      const empId = employeeIds.get(empName);
      const hours = empData?.hours || 0;
      const rate = empId ? getBillRate(db, empId, cust.id) : 0;
      const amount = round2(hours * rate);

      row.push(hours || "", rate || "", amount || "");
      rowTotal += amount;

      // Accumulate employee totals
      const empTotals = employeeTotals.get(empName);
      empTotals.hours += hours;
      empTotals.amount += amount;
    }

    row.push(round2(rowTotal));
    grandTotal += rowTotal;
    ws.addRow(row);
  }

  // Add totals row
  ws.addRow([]); // blank row
  const totalsRow = ["TOTALS"];
  for (const empName of employees) {
    const empTotals = employeeTotals.get(empName);
    totalsRow.push(
      round2(empTotals.hours),
      "", // rate column blank for totals
      round2(empTotals.amount)
    );
  }
  totalsRow.push(round2(grandTotal));
  const totalsRowRef = ws.addRow(totalsRow);
  totalsRowRef.font = { bold: true };
  totalsRowRef.fill = {
    type: "pattern",
    pattern: "solid",
    fgColor: { argb: "FFFFE0B0" },
  };

  // Add Admin vs Hourly breakdown section
  ws.addRow([]);
  ws.addRow(["CATEGORY BREAKDOWN"]);
  ws.addRow(["Employee", "Category", "Total Hours", "Regular Hours", "OT Hours", "Total Amount"]);
  
  // Calculate per-employee category breakdown
  const empWeeklyHours = new Map(); // employee -> week -> hours
  for (const row of entries) {
    const weekStart = getWeekStart(row.work_date);
    const key = `${row.employee_name}|${weekStart}`;
    empWeeklyHours.set(key, (empWeeklyHours.get(key) || 0) + Number(row.hours));
  }

  for (const empName of employees) {
    const category = getEmployeeCategory(empName);
    const empTotals = employeeTotals.get(empName);
    
    // Calculate OT by looking at weekly totals
    let regularHours = 0;
    let otHours = 0;
    
    // Group by week for this employee
    const weeklyTotals = new Map();
    for (const [key, hours] of empWeeklyHours) {
      if (key.startsWith(empName + "|")) {
        const weekStart = key.split("|")[1];
        weeklyTotals.set(weekStart, hours);
      }
    }
    
    for (const [week, weekHours] of weeklyTotals) {
      const calc = calculatePayWithOT(weekHours, 1, category);
      regularHours += calc.regularHours;
      otHours += calc.otHours;
    }
    
    ws.addRow([
      empName,
      category.toUpperCase(),
      round2(empTotals.hours),
      round2(regularHours),
      round2(otHours),
      round2(empTotals.amount),
    ]);
  }

  // Set column widths
  ws.getColumn(1).width = 30; // Client column
  for (let i = 2; i <= header.length; i++) {
    ws.getColumn(i).width = 12;
  }

  // Format currency columns
  for (let i = 0; i < employees.length; i++) {
    const rateCol = 3 + i * 3; // Rate columns
    const amountCol = 4 + i * 3; // Amount columns
    ws.getColumn(rateCol).numFmt = '"$"#,##0.00';
    ws.getColumn(amountCol).numFmt = '"$"#,##0.00';
  }

  // Save file
  const filename = `Payroll_Breakdown_${month}.xlsx`;
  const filepath = path.join(outputDir, filename);
  await workbook.xlsx.writeFile(filepath);

  // Build totals summary
  const totals = {
    month,
    customers: sortedCustomers.length,
    employees: employees.length,
    byEmployee: Object.fromEntries(employeeTotals),
    grandTotal: round2(grandTotal),
  };

  console.log(`[generateMonthly] Month ${month}: ${sortedCustomers.length} customers, ${employees.length} employees`);
  console.log(`[generateMonthly] Grand Total: $${totals.grandTotal}`);

  return { filepath, filename, totals, outputDir };
}

// Helper: get Monday of the week for a given date
function getWeekStart(ymd) {
  const [y, m, d] = ymd.split("-").map(Number);
  const date = new Date(y, m - 1, d);
  const day = date.getDay();
  const diff = day === 0 ? -6 : 1 - day; // Monday = 1
  date.setDate(date.getDate() + diff);
  return formatYmd(date);
}

function formatYmd(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function round2(n) {
  return Math.round(Number(n) * 100) / 100;
}

--o--
=== public/index.html ===
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labor Timekeeper - Login</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Labor Timekeeper</h1>
      <p class="muted">Log hours by day and customer. Voice optional.</p>
      <div class="row">
        <div class="col">
          <label class="small muted">Employee</label>
          <input id="name" placeholder="e.g., Chris Jacobi" />
        </div>
        <div class="col">
          <label class="small muted">PIN</label>
          <input id="pin" placeholder="4 digits" inputmode="numeric" />
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <div class="col"><button class="primary" id="loginBtn">Login</button></div>
        <div class="col"><a class="muted" href="/admin">Admin</a></div>
      </div>
      <p id="msg" class="muted"></p>
      <hr/>
      <p class="muted small">Seed test users: Chris Jacobi (1111), Chris Z (2222), Office Admin (9999)</p>
    </div>
  </div>

<script>
async function login() {
  const name = document.getElementById('name').value.trim();
  const pin = document.getElementById('pin').value.trim();
  const msg = document.getElementById('msg');
  msg.textContent = '';
  const r = await fetch('/api/login', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({name, pin})
  });
  const j = await r.json().catch(()=>({}));
  if (!r.ok) { msg.textContent = j.error || 'Login failed'; return; }
  location.href = '/app';
}
document.getElementById('loginBtn').addEventListener('click', login);
document.getElementById('pin').addEventListener('keydown', (e)=>{ if(e.key==='Enter') login(); });
</script>
</body>
</html>

--o--
=== public/app.html ===
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labor Timekeeper</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <div class="row" style="align-items:center; justify-content:space-between;">
      <div>
        <h1>Log Hours</h1>
        <div class="muted small" id="who"></div>
      </div>
      <div style="display:flex; gap:8px;">
        <a href="/admin" class="badge">Admin</a>
        <button class="danger" id="logoutBtn" style="width:auto;">Logout</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>This Week</h2>
      <div class="muted small" id="weekLabel"></div>

      <div class="row" style="margin-top:12px;">
        <div class="col">
          <label class="small muted">Customer</label>
          <select id="customer"></select>
        </div>
        <div class="col">
          <label class="small muted">Day</label>
          <select id="day"></select>
        </div>
        <div class="col">
          <label class="small muted">Hours</label>
          <input id="hours" placeholder="e.g., 8" inputmode="decimal" />
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <div class="col"><button class="primary" id="saveBtn">Save / Update</button></div>
        <div class="col"><button id="submitBtn">Submit Week</button></div>
      </div>

      <hr/>

      <h2>ðŸŽ¤ Speak it</h2>
      <p class="muted small">Example: â€œMcGill 8 hours Fridayâ€ or â€œ8 hours Friday McGill, 2 hours Saturday Hallâ€.</p>
      <div class="row">
        <div class="col"><button class="primary" id="recBtn">Start Recording</button></div>
        <div class="col"><button id="applyVoiceBtn" disabled>Apply Parsed Entries</button></div>
      </div>
      <p class="muted small" id="voiceStatus"></p>
      <div id="voiceBox" class="toast" style="display:none;">
        <div class="small muted">Transcript</div>
        <div id="transcript" style="margin:6px 0 10px 0;"></div>
        <div class="small muted">Parsed entries</div>
        <div id="parsed"></div>
      </div>

      <hr/>

      <h2>Entries</h2>
      <div id="entries"></div>
    </div>
  </div>

<script>
let ME=null, CUSTOMERS=[], WEEK=null;
let mediaRecorder=null, chunks=[], lastParsed=null;

// Draft persistence key
const DRAFT_KEY = 'labor_timekeeper_draft';

function el(id){ return document.getElementById(id); }
function fmt(n){ return (Math.round(n*100)/100).toString(); }

async function api(url, opts){
  const r = await fetch(url, opts);
  if (r.status===401) location.href='/';
  const j = await r.json().catch(()=>null);
  if (!r.ok) throw new Error((j && j.error) || 'Request failed');
  return j;
}

// Draft persistence functions
function saveDraft() {
  const notesEl = el('notes');
  const draft = {
    customer: el('customer').value,
    day: el('day').value,
    hours: el('hours').value,
    notes: notesEl ? notesEl.value : '',
    savedAt: new Date().toISOString()
  };
  localStorage.setItem(DRAFT_KEY, JSON.stringify(draft));
}

function loadDraft() {
  try {
    const saved = localStorage.getItem(DRAFT_KEY);
    if (!saved) return null;
    return JSON.parse(saved);
  } catch {
    return null;
  }
}

function clearDraft() {
  localStorage.removeItem(DRAFT_KEY);
}

function restoreDraft() {
  const draft = loadDraft();
  if (!draft) return;
  
  // Only restore if saved within last 24 hours
  const savedAt = new Date(draft.savedAt);
  const hoursSinceSave = (Date.now() - savedAt.getTime()) / (1000 * 60 * 60);
  if (hoursSinceSave > 24) {
    clearDraft();
    return;
  }
  
  // Restore values
  if (draft.customer) el('customer').value = draft.customer;
  if (draft.day) el('day').value = draft.day;
  if (draft.hours) el('hours').value = draft.hours;
  if (draft.notes) el('notes').value = draft.notes;
  
  console.log('[Draft] Restored unsaved form data from', draft.savedAt);
}

async function init(){
  ME = await api('/api/me');
  el('who').textContent = `Logged in as ${ME.name}`;

  CUSTOMERS = await api('/api/customers');
  el('customer').innerHTML = CUSTOMERS.map(c=>`<option value="${c.id}">${c.name}</option>`).join('');

  const week = await api('/api/time-entries');
  WEEK = week;
  el('weekLabel').textContent = `Week starting ${week.week_start}`;
  el('day').innerHTML = week.days.map(d=>`<option value="${d.ymd}">${d.dow} (${d.ymd})</option>`).join('');
  renderEntries(week.entries);

  el('saveBtn').onclick = saveEntry;
  el('submitBtn').onclick = submitWeek;
  el('logoutBtn').onclick = logout;

  // Restore draft data if present
  restoreDraft();

  // Auto-save draft on form changes
  ['customer', 'day', 'hours'].forEach(id => {
    if (el(id)) {
      el(id).addEventListener('input', saveDraft);
      el(id).addEventListener('change', saveDraft);
    }
  });

  await setupRecorder();
}

function renderEntries(entries){
  if (!entries.length){
    el('entries').innerHTML = '<p class="muted">No entries yet.</p>';
    return;
  }
  const rows = entries.map(e=>{
    const badge = e.status==='APPROVED'
      ? '<span class="badge">APPROVED</span>'
      : e.status==='SUBMITTED'
        ? '<span class="badge">SUBMITTED</span>'
        : '<span class="badge">DRAFT</span>';
    return `<tr>
      <td>${e.work_date}</td>
      <td>${e.customer_name}</td>
      <td>${fmt(Number(e.hours))}</td>
      <td>${badge}</td>
    </tr>`;
  }).join('');
  el('entries').innerHTML = `
    <table>
      <thead><tr><th>Date</th><th>Customer</th><th>Hours</th><th>Status</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

async function refresh(){
  const week = await api('/api/time-entries');
  WEEK = week;
  renderEntries(week.entries);
}

async function saveEntry(){
  const customer_id = el('customer').value;
  const work_date = el('day').value;
  const hours = parseFloat(el('hours').value);
  if (!customer_id || !work_date || !isFinite(hours)) { alert('Pick customer/day and enter hours'); return; }
  await api('/api/time-entries', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({customer_id, work_date, hours})
  });
  el('hours').value='';
  clearDraft(); // Clear saved draft after successful save
  await refresh();
}

async function submitWeek(){
  await api('/api/submit-week', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({week_start: WEEK.week_start})
  });
  alert('Submitted!');
  await refresh();
}

async function logout(){
  await fetch('/api/logout', { method:'POST' });
  location.href='/';
}

async function setupRecorder(){
  const recBtn = el('recBtn');
  const applyBtn = el('applyVoiceBtn');

  applyBtn.onclick = applyParsed;

  try{
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

    mediaRecorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };

    mediaRecorder.onstop = async () => {
      try{
        el('voiceStatus').textContent = 'Processing...';
        const blob = new Blob(chunks, { type:'audio/webm' });
        const fd = new FormData();
        fd.append('audio', blob, 'command.webm');
        const result = await api('/api/voice/command', { method:'POST', body: fd });
        showVoiceResult(result);
      } catch(err){
        el('voiceStatus').textContent = err.message;
      }
    };

    recBtn.onclick = () => {
      if (mediaRecorder.state === 'inactive'){
        chunks = [];
        mediaRecorder.start();
        recBtn.textContent = 'Stop Recording';
        el('voiceStatus').textContent = 'Recording...';
        applyBtn.disabled = true;
        lastParsed = null;
      } else {
        mediaRecorder.stop();
        recBtn.textContent = 'Start Recording';
      }
    };
  } catch(e){
    el('voiceStatus').textContent = 'Microphone permission denied or unsupported browser.';
    recBtn.disabled = true;
  }
}

function showVoiceResult(result){
  el('voiceStatus').textContent = '';
  el('voiceBox').style.display = 'block';
  el('transcript').textContent = result.transcript || '';
  const entries = result.parsed?.entries || [];
  lastParsed = entries;

  el('parsed').innerHTML = entries.map((e)=>{
    const warn = e.customer_id
      ? ''
      : ' <span class="badge" style="border-color:rgba(255,107,107,.4); color:#ffb3b3;">needs customer match</span>';
    return `<div style="margin:6px 0;">
      <strong>${e.work_date}</strong> â€” ${e.customer_name} â€” ${fmt(Number(e.hours))} hrs${warn}
    </div>`;
  }).join('') || '<div class="muted">No entries parsed.</div>';

  el('applyVoiceBtn').disabled = entries.length === 0 || entries.some(e=>!e.customer_id);
}

async function applyParsed(){
  if (!lastParsed?.length) return;
  for (const e of lastParsed){
    await api('/api/time-entries', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        customer_id: e.customer_id,
        work_date: e.work_date,
        hours: e.hours,
        notes: e.notes || ''
      })
    });
  }
  alert('Applied!');
  await refresh();
}

init().catch(e=>{
  console.error(e);
  alert(e.message || 'Failed to load');
});
</script>

</body>
</html>

--o--
=== public/admin.html ===
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labor Timekeeper - Admin</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <div class="row" style="align-items:center; justify-content:space-between;">
      <div>
        <h1>Admin</h1>
        <div class="muted small" id="who"></div>
      </div>
      <div style="display:flex; gap:8px;">
        <a href="/app" class="badge">Employee view</a>
        <a href="/" class="badge">Login</a>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>Approvals</h2>
      <div class="row">
        <div class="col">
          <label class="small muted">Week start (YYYY-MM-DD)</label>
          <input id="weekStart" placeholder="YYYY-MM-DD" />
        </div>
        <div class="col">
          <label class="small muted">&nbsp;</label>
          <button class="primary" id="loadBtn">Load Submitted</button>
        </div>
      </div>

      <div id="submitted" style="margin-top:12px;"></div>

      <div class="row" style="margin-top:12px;">
        <div class="col"><button id="approveBtn" class="primary">Approve Selected</button></div>
        <div class="col"><button id="exportMonthBtn">Export Monthly Summary</button></div>
      </div>

      <hr/>

      <h2>ðŸ“Š Payroll XLSX Pipeline</h2>
      <div class="row">
        <div class="col">
          <label class="small muted">Week Start</label>
          <input id="pipelineWeek" placeholder="YYYY-MM-DD" />
        </div>
        <div class="col">
          <label class="small muted">Month</label>
          <input id="pipelineMonth" placeholder="YYYY-MM" />
        </div>
      </div>
      <div class="row" style="margin-top:12px; gap:8px;">
        <button id="genWeekBtn" class="primary">Generate Weekly (per Employee)</button>
        <button id="genMonthBtn" class="primary">Generate Monthly Breakdown</button>
        <button id="genBothBtn" style="background:#2ecc71;">Generate Both</button>
      </div>
      <div id="pipelineResult" style="margin-top:12px; padding:10px; background:#f8f9fa; border-radius:4px; display:none;">
        <pre id="pipelineOutput" style="margin:0; white-space:pre-wrap; font-size:12px;"></pre>
      </div>

      <hr/>

      <h2>ðŸ—‘ï¸ Close Month (Retention Policy)</h2>
      <div class="row">
        <div class="col">
          <label class="small muted">Month to Close</label>
          <input id="closeMonth" placeholder="YYYY-MM" />
        </div>
        <div class="col">
          <label class="small muted">&nbsp;</label>
          <button id="closeMonthBtn" style="background:#e74c3c; color:white;">Close & Delete Entries</button>
        </div>
      </div>
      <p class="muted small">âš ï¸ This permanently deletes all time entries for the specified month.</p>

      <hr/>

      <h2>Invoice Export</h2>
      <div class="row">
        <div class="col">
          <label class="small muted">Customer</label>
          <select id="customer"></select>
        </div>
        <div class="col">
          <label class="small muted">Start</label>
          <input id="start" placeholder="YYYY-MM-DD" />
        </div>
        <div class="col">
          <label class="small muted">End</label>
          <input id="end" placeholder="YYYY-MM-DD" />
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <div class="col"><button id="exportInvoiceBtn" class="primary">Download Invoice Workbook</button></div>
      </div>

      <p class="muted small" id="msg"></p>
    </div>
  </div>

<script>
function el(id){ return document.getElementById(id); }

async function api(url, opts){
  const r = await fetch(url, opts);
  if (r.status===401) { location.href='/'; return; }
  const j = await r.json().catch(()=>null);
  if (!r.ok) throw new Error((j && j.error) || 'Request failed');
  return j;
}

let submittedCache=[];

async function init(){
  const me = await api('/api/me');
  if (!me.is_admin) { alert('Admin only'); location.href='/app'; return; }
  el('who').textContent = `Logged in as ${me.name} (admin)`;

  const customers = await api('/api/customers');
  el('customer').innerHTML = customers.map(c=>`<option value="${c.id}">${c.name}</option>`).join('');

  el('loadBtn').onclick = loadSubmitted;
  el('approveBtn').onclick = approveSelected;
  el('exportMonthBtn').onclick = exportMonth;
  el('exportInvoiceBtn').onclick = exportInvoice;

  // Pipeline buttons
  el('genWeekBtn').onclick = generateWeekly;
  el('genMonthBtn').onclick = generateMonthlyBreakdown;
  el('genBothBtn').onclick = generateBoth;
  el('closeMonthBtn').onclick = closeMonth;

  // Set default values for pipeline inputs
  const now = new Date();
  const ym = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
  el('pipelineMonth').value = ym;
  el('closeMonth').value = ym;

  // default week start: ask server by loading approvals once without week
  const data = await api('/api/approvals');
  el('weekStart').value = data.week_start;
  el('pipelineWeek').value = data.week_start;
  submittedCache = data.submitted;
  renderSubmitted(data.submitted);
}

// Pipeline functions
async function generateWeekly() {
  const week_start = el('pipelineWeek').value.trim();
  if (!week_start) { alert('Enter week start date'); return; }
  try {
    showPipelineResult('Generating weekly exports...');
    const result = await api(`/api/admin/generate-week?week_start=${encodeURIComponent(week_start)}`);
    const output = [
      `âœ… Weekly Export Complete`,
      `Week: ${result.weekStart}`,
      `Output: ${result.outputDir}`,
      ``,
      `Files Generated (${result.files.length}):`,
      ...result.files.map(f => `  â€¢ ${f.filename}: ${f.hours}hrs ($${f.amount}) [${f.category}]`),
      ``,
      `Totals:`,
      `  Hours: ${result.totals.totalHours} (${result.totals.totalRegular} reg + ${result.totals.totalOT} OT)`,
      `  Amount: $${result.totals.totalAmount}`,
    ].join('\n');
    showPipelineResult(output);
  } catch (err) {
    showPipelineResult(`âŒ Error: ${err.message}`);
  }
}

async function generateMonthlyBreakdown() {
  const month = el('pipelineMonth').value.trim();
  if (!month) { alert('Enter month'); return; }
  try {
    showPipelineResult('Generating monthly breakdown...');
    const result = await api(`/api/admin/generate-month?month=${encodeURIComponent(month)}`);
    const output = [
      `âœ… Monthly Export Complete`,
      `Month: ${result.month}`,
      `File: ${result.filename}`,
      ``,
      `Summary:`,
      `  Customers: ${result.totals.customers}`,
      `  Employees: ${result.totals.employees}`,
      `  Grand Total: $${result.totals.grandTotal}`,
    ].join('\n');
    showPipelineResult(output);
  } catch (err) {
    showPipelineResult(`âŒ Error: ${err.message}`);
  }
}

async function generateBoth() {
  try {
    showPipelineResult('Generating both weekly and monthly exports...');
    
    const week_start = el('pipelineWeek').value.trim();
    const month = el('pipelineMonth').value.trim();
    
    const weekResult = week_start ? await api(`/api/admin/generate-week?week_start=${encodeURIComponent(week_start)}`) : null;
    const monthResult = month ? await api(`/api/admin/generate-month?month=${encodeURIComponent(month)}`) : null;
    
    let output = 'âœ… Export Complete\n\n';
    
    if (weekResult) {
      output += `WEEKLY (${weekResult.weekStart}):\n`;
      output += `  Files: ${weekResult.files.length}\n`;
      output += `  Hours: ${weekResult.totals.totalHours}\n`;
      output += `  Amount: $${weekResult.totals.totalAmount}\n\n`;
    }
    
    if (monthResult) {
      output += `MONTHLY (${monthResult.month}):\n`;
      output += `  File: ${monthResult.filename}\n`;
      output += `  Grand Total: $${monthResult.totals.grandTotal}\n`;
    }
    
    showPipelineResult(output);
  } catch (err) {
    showPipelineResult(`âŒ Error: ${err.message}`);
  }
}

async function closeMonth() {
  const month = el('closeMonth').value.trim();
  if (!month) { alert('Enter month to close'); return; }
  
  const confirmed = confirm(`âš ï¸ WARNING: This will permanently delete ALL time entries for ${month}.\n\nAre you sure?`);
  if (!confirmed) return;
  
  const doubleConfirm = confirm(`FINAL CONFIRMATION: Delete all entries for ${month}?`);
  if (!doubleConfirm) return;
  
  try {
    showPipelineResult('Closing month...');
    const result = await api('/api/admin/close-month', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ month, confirm: true })
    });
    showPipelineResult(`âœ… ${result.message}`);
  } catch (err) {
    showPipelineResult(`âŒ Error: ${err.message}`);
  }
}

function showPipelineResult(text) {
  el('pipelineResult').style.display = 'block';
  el('pipelineOutput').textContent = text;
}

async function loadSubmitted(){
  const week_start = el('weekStart').value.trim();
  const data = await api('/api/approvals?week_start=' + encodeURIComponent(week_start));
  submittedCache = data.submitted;
  renderSubmitted(data.submitted);
}

function renderSubmitted(rows){
  if (!rows.length){
    el('submitted').innerHTML = '<p class="muted">No submitted entries.</p>';
    return;
  }
  const html = `
    <table>
      <thead><tr>
        <th></th><th>Date</th><th>Employee</th><th>Customer</th><th>Hours</th>
      </tr></thead>
      <tbody>
        ${rows.map(r=>`
          <tr>
            <td><input type="checkbox" data-id="${r.id}" /></td>
            <td>${r.work_date}</td>
            <td>${r.employee_name}</td>
            <td>${r.customer_name}</td>
            <td>${Number(r.hours)}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
  el('submitted').innerHTML = html;
}

async function approveSelected(){
  const ids = [...document.querySelectorAll('input[type=checkbox][data-id]:checked')].map(x=>x.getAttribute('data-id'));
  if (!ids.length) { alert('Select at least one.'); return; }
  await api('/api/approve', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ ids })
  });
  alert('Approved!');
  await loadSubmitted();
}

function exportMonth(){
  const d = new Date();
  const ym = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
  window.location.href = `/api/export/monthly?month=${encodeURIComponent(ym)}`;
}

function exportInvoice(){
  const customer_id = el('customer').value;
  const start = el('start').value.trim();
  const end = el('end').value.trim();
  if (!customer_id || !start || !end) { alert('Pick customer and start/end dates'); return; }
  window.location.href = `/api/export/invoice?customer_id=${encodeURIComponent(customer_id)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;
}

init().catch(e=>{
  console.error(e);
  alert(e.message || 'Failed to load');
});
</script>
</body>
</html>

--o--
=== public/styles.css ===
:root { --bg:#0b1020; --card:#111a33; --muted:#7d8bb3; --text:#eef2ff; --accent:#6ea8fe; --danger:#ff6b6b; }
*{ box-sizing:border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
body{ margin:0; background:linear-gradient(180deg,#070b16,#0b1020); color:var(--text); }
a{ color:var(--accent); text-decoration:none; }
.container{ max-width:980px; margin:0 auto; padding:20px; }
.card{ background:rgba(17,26,51,.9); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:16px; box-shadow:0 12px 40px rgba(0,0,0,.35); }
.row{ display:flex; gap:12px; flex-wrap:wrap; }
.col{ flex:1 1 240px; }
h1,h2{ margin:0 0 10px 0; }
.muted{ color:var(--muted); }
input,select,button,textarea{ width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--text); }
button{ cursor:pointer; background:rgba(110,168,254,.18); border-color:rgba(110,168,254,.35); }
button:hover{ background:rgba(110,168,254,.28); }
button.primary{ background:rgba(110,168,254,.35); }
button.danger{ background:rgba(255,107,107,.18); border-color:rgba(255,107,107,.35); }
table{ width:100%; border-collapse:separate; border-spacing:0; }
th,td{ padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.08); font-size:14px; }
th{ text-align:left; color:var(--muted); font-weight:600; }
.badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); color:var(--muted); }
.grid{ display:grid; grid-template-columns: repeat(8, 1fr); gap:8px; align-items:center; }
.grid .head{ color:var(--muted); font-weight:600; }
.small{ font-size:12px; }
hr{ border:none; border-top:1px solid rgba(255,255,255,.08); margin:14px 0; }
.toast{ padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.25); }

--o--
=== scripts/seed.js ===
import fs from "fs";
import path from "path";
import { openDb, id } from "../lib/db.js";
import { hashPin } from "../lib/auth.js";

const db = openDb();

function readJson(rel) {
  const p = path.resolve(process.cwd(), rel);
  return JSON.parse(fs.readFileSync(p, "utf-8"));
}

const customers = readJson("./seed/customers.json");
const employees = readJson("./seed/employees.json");
const overrides = readJson("./seed/rate_overrides.json");

const now = new Date().toISOString();

db.transaction(() => {
  // Customers
  const insertCustomer = db.prepare("INSERT OR IGNORE INTO customers (id, name, created_at) VALUES (?, ?, ?)");
  for (const name of customers) {
    insertCustomer.run(id("cust_"), name, now);
  }

  // Employees
  const insertEmployee = db.prepare(`
    INSERT OR IGNORE INTO employees
      (id, name, pin_hash, default_bill_rate, default_pay_rate, is_admin, aliases_json, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  for (const e of employees) {
    insertEmployee.run(
      id("emp_"),
      e.name,
      hashPin(e.pin || "0000"),
      Number(e.default_bill_rate || 0),
      Number(e.default_pay_rate || 0),
      e.is_admin ? 1 : 0,
      JSON.stringify(e.aliases || []),
      now
    );
  }

  // Rate overrides
  const getEmp = db.prepare("SELECT id FROM employees WHERE name = ?");
  const getCust = db.prepare("SELECT id FROM customers WHERE name = ?");
  const upsert = db.prepare(`
    INSERT INTO rate_overrides (id, employee_id, customer_id, bill_rate, created_at)
    VALUES (?, ?, ?, ?, ?)
    ON CONFLICT(employee_id, customer_id) DO UPDATE SET bill_rate=excluded.bill_rate
  `);

  for (const o of overrides) {
    // employee_name in overrides is "Chris J"/"Chris Z" from template; map "Chris J" => "Chris Jacobi"
    const empName = o.employee_name === "Chris J" ? "Chris Jacobi" : o.employee_name;
    const emp = getEmp.get(empName);
    const cust = getCust.get(o.customer_name);
    if (!emp || !cust) continue;
    upsert.run(id("ro_"), emp.id, cust.id, Number(o.bill_rate), now);
  }
})();

const counts = {
  customers: db.prepare("SELECT COUNT(*) as n FROM customers").get().n,
  employees: db.prepare("SELECT COUNT(*) as n FROM employees").get().n,
  overrides: db.prepare("SELECT COUNT(*) as n FROM rate_overrides").get().n
};

console.log("Seed complete:", counts);

--o--
=== scripts/simulate.js ===
#!/usr/bin/env node
/**
 * Simulation Script for Labor Timekeeper
 * Generates sample time entries and runs the export pipeline
 * 
 * Usage:
 *   npm run simulate                    # Generate and export
 *   npm run simulate -- --reset         # Reset DB first
 *   npm run simulate -- --submit        # Auto-submit entries
 *   npm run simulate -- --approve       # Auto-approve entries
 *   npm run simulate -- --reset --submit --approve  # Full pipeline
 */

import { openDb, id } from "../lib/db.js";
import { weekStartYMD, todayYMD } from "../lib/time.js";
import { generateWeeklyExports } from "../lib/export/generateWeekly.js";
import { generateMonthlyExport } from "../lib/export/generateMonthly.js";
import { getHolidaysForYear } from "../lib/holidays.js";

const args = process.argv.slice(2);
const RESET = args.includes("--reset");
const SUBMIT = args.includes("--submit");
const APPROVE = args.includes("--approve");

const db = openDb();

// Sample data for simulation - using actual seeded customers
const SAMPLE_ENTRIES = [
  // Chris Jacobi - Admin (no OT)
  { employee: "Chris Jacobi", customer: "McGill", hours: 8, dayOffset: 0 },
  { employee: "Chris Jacobi", customer: "Hall", hours: 8, dayOffset: 1 },
  { employee: "Chris Jacobi", customer: "McGill", hours: 8, dayOffset: 2 },
  { employee: "Chris Jacobi", customer: "Bryan", hours: 10, dayOffset: 3 },
  { employee: "Chris Jacobi", customer: "McGill", hours: 8, dayOffset: 4 },
  
  // Chris Z - Admin (no OT)
  { employee: "Chris Z", customer: "Hall", hours: 9, dayOffset: 0 },
  { employee: "Chris Z", customer: "Bryan", hours: 8, dayOffset: 1 },
  { employee: "Chris Z", customer: "McGill", hours: 7, dayOffset: 2 },
  { employee: "Chris Z", customer: "Hall", hours: 8, dayOffset: 3 },
  { employee: "Chris Z", customer: "Bryan", hours: 10, dayOffset: 4 },
  
  // Doug Kinsey - Hourly (gets OT)
  { employee: "Doug Kinsey", customer: "McGill", hours: 10, dayOffset: 0 },
  { employee: "Doug Kinsey", customer: "Hall", hours: 10, dayOffset: 1 },
  { employee: "Doug Kinsey", customer: "Bryan", hours: 10, dayOffset: 2 },
  { employee: "Doug Kinsey", customer: "McGill", hours: 10, dayOffset: 3 },
  { employee: "Doug Kinsey", customer: "Hall", hours: 8, dayOffset: 4 }, // 48 total -> 8 OT
  
  // Jafid Osorio - Hourly
  { employee: "Jafid Osorio", customer: "Bryan", hours: 8, dayOffset: 0 },
  { employee: "Jafid Osorio", customer: "McGill", hours: 8, dayOffset: 1 },
  { employee: "Jafid Osorio", customer: "Hall", hours: 8, dayOffset: 2 },
  { employee: "Jafid Osorio", customer: "Bryan", hours: 8, dayOffset: 3 },
  { employee: "Jafid Osorio", customer: "McGill", hours: 8, dayOffset: 4 }, // 40 total, no OT
];

async function main() {
  console.log("=".repeat(60));
  console.log("Labor Timekeeper - Simulation Script");
  console.log("=".repeat(60));
  console.log(`Options: RESET=${RESET}, SUBMIT=${SUBMIT}, APPROVE=${APPROVE}`);
  console.log();

  // Get current week info
  const weekStart = weekStartYMD();
  const today = todayYMD();
  const month = today.slice(0, 7);
  
  console.log(`Week Start: ${weekStart}`);
  console.log(`Today: ${today}`);
  console.log(`Month: ${month}`);
  console.log();

  // Reset if requested
  if (RESET) {
    console.log("[RESET] Clearing existing time entries...");
    db.prepare("DELETE FROM time_entries").run();
    console.log("[RESET] Done.\n");
  }

  // Generate sample entries
  console.log("[GENERATE] Creating sample time entries...");
  
  const employees = db.prepare("SELECT * FROM employees").all();
  const customers = db.prepare("SELECT * FROM customers").all();
  
  const empMap = new Map(employees.map(e => [e.name, e]));
  const custMap = new Map(customers.map(c => [c.name, c]));
  
  let created = 0;
  for (const entry of SAMPLE_ENTRIES) {
    const emp = empMap.get(entry.employee);
    const cust = custMap.get(entry.customer);
    
    if (!emp || !cust) {
      console.log(`  [SKIP] Missing emp=${entry.employee} or cust=${entry.customer}`);
      continue;
    }
    
    // Calculate work date based on week start + offset
    const [y, m, d] = weekStart.split("-").map(Number);
    const workDate = new Date(y, m - 1, d + entry.dayOffset);
    const workDateYmd = formatYmd(workDate);
    
    // Check if entry already exists
    const existing = db.prepare(`
      SELECT id FROM time_entries 
      WHERE employee_id = ? AND customer_id = ? AND work_date = ?
    `).get(emp.id, cust.id, workDateYmd);
    
    if (existing) {
      console.log(`  [SKIP] Entry exists: ${entry.employee} @ ${entry.customer} on ${workDateYmd}`);
      continue;
    }
    
    const status = APPROVE ? "APPROVED" : (SUBMIT ? "SUBMITTED" : "DRAFT");
    
    db.prepare(`
      INSERT INTO time_entries (id, employee_id, customer_id, work_date, hours, notes, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
    `).run(id("te_"), emp.id, cust.id, workDateYmd, entry.hours, "", status);
    
    created++;
    console.log(`  [CREATE] ${entry.employee} @ ${entry.customer}: ${entry.hours}hrs on ${workDateYmd} [${status}]`);
  }
  
  console.log(`[GENERATE] Created ${created} entries.\n`);

  // Show holidays for reference
  const year = parseInt(today.slice(0, 4), 10);
  const holidays = getHolidaysForYear(year);
  console.log(`[HOLIDAYS] ${year}:`);
  holidays.forEach(h => console.log(`  â€¢ ${h.date}: ${h.name}`));
  console.log();

  // If entries are approved, run exports
  if (APPROVE) {
    console.log("[EXPORT] Generating XLSX exports...\n");
    
    // Weekly exports
    console.log("--- Weekly Exports ---");
    const weekResult = await generateWeeklyExports({ db, weekStart });
    console.log(`Generated ${weekResult.files.length} files in ${weekResult.outputDir}`);
    weekResult.files.forEach(f => {
      console.log(`  â€¢ ${f.filename}: ${f.hours}hrs ($${f.amount}) [${f.category}]`);
    });
    console.log(`Totals: ${weekResult.totals.totalHours}hrs = $${weekResult.totals.totalAmount}`);
    console.log();
    
    // Monthly export
    console.log("--- Monthly Export ---");
    const monthResult = await generateMonthlyExport({ db, month });
    console.log(`Generated: ${monthResult.filename}`);
    console.log(`Grand Total: $${monthResult.totals.grandTotal}`);
    console.log();
  } else {
    console.log("[INFO] Run with --approve to generate exports.\n");
  }

  // Summary
  const counts = db.prepare(`
    SELECT status, COUNT(*) as cnt FROM time_entries GROUP BY status
  `).all();
  
  console.log("[SUMMARY] Time Entry Status:");
  counts.forEach(c => console.log(`  ${c.status}: ${c.cnt}`));
  
  console.log("\n" + "=".repeat(60));
  console.log("Simulation complete!");
  console.log("=".repeat(60));
}

function formatYmd(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

main().catch(err => {
  console.error("Simulation failed:", err);
  process.exit(1);
});

--o--
=== tests/labor-timekeeper.spec.cjs ===
// @ts-check
const { test, expect } = require('@playwright/test');

test.describe('Labor Timekeeper', () => {
  
  // =====================
  // LOGIN TESTS
  // =====================
  test.describe('Authentication', () => {
    
    test('should show login form on home page', async ({ page }) => {
      await page.goto('/');
      await expect(page.locator('#pin')).toBeVisible();
      await expect(page.locator('#loginBtn')).toBeVisible();
    });

    test('should login with valid PIN and redirect to app', async ({ page }) => {
      await page.goto('/');
      await page.fill('#name', 'Chris Jacobi');
      await page.fill('#pin', '1111');
      await page.click('#loginBtn');
      await page.waitForURL('/app');
      await expect(page).toHaveURL('/app');
    });

    test('should reject invalid PIN', async ({ page }) => {
      await page.goto('/');
      await page.fill('#name', 'Chris Jacobi');
      await page.fill('#pin', '0000');
      await page.click('#loginBtn');
      // Should show error message
      await expect(page.locator('#msg')).toContainText(/fail|invalid|error/i);
    });
  });

  // =====================
  // APP PAGE TESTS
  // =====================
  test.describe('Time Entry App', () => {
    
    test.beforeEach(async ({ page }) => {
      // Login as Chris Jacobi
      await page.goto('/');
      await page.fill('#name', 'Chris Jacobi');
      await page.fill('#pin', '1111');
      await page.click('#loginBtn');
      await page.waitForURL('/app');
    });

    test('should display employee name after login', async ({ page }) => {
      await expect(page.locator('#who')).toContainText(/Chris Jacobi/i);
    });

    test('should show customer dropdown', async ({ page }) => {
      const customerSelect = page.locator('#customer');
      await expect(customerSelect).toBeVisible();
    });

    test('should have hours input field', async ({ page }) => {
      const hoursInput = page.locator('#hours');
      await expect(hoursInput).toBeVisible();
    });

    test('should persist draft in localStorage', async ({ page }) => {
      const hoursInput = page.locator('#hours');
      await hoursInput.fill('8');
      
      await page.waitForTimeout(600);
      
      const draft = await page.evaluate(() => localStorage.getItem('labor_timekeeper_draft'));
      expect(draft).toBeTruthy();
      expect(draft).toContain('8');
    });
  });

  // =====================
  // ADMIN PAGE TESTS
  // =====================
  test.describe('Admin Dashboard', () => {
    
    test.beforeEach(async ({ page }) => {
      // Login as Office Admin (PIN 9999)
      await page.goto('/');
      await page.fill('#name', 'Office Admin');
      await page.fill('#pin', '9999');
      await page.click('#loginBtn');
      await page.waitForURL('/app');
      // Navigate to admin
      await page.goto('/admin');
    });

    test('should display admin dashboard', async ({ page }) => {
      await expect(page.locator('body')).toContainText(/Admin|Pending/i);
    });

    test('should have Generate Weekly Exports button', async ({ page }) => {
      const weeklyBtn = page.locator('#genWeekBtn');
      await expect(weeklyBtn).toBeVisible();
    });

    test('should have Generate Monthly Breakdown button', async ({ page }) => {
      const monthlyBtn = page.locator('#genMonthBtn');
      await expect(monthlyBtn).toBeVisible();
    });

    test('should show pending entries table', async ({ page }) => {
      const table = page.locator('table');
      await expect(table).toBeVisible();
    });

    test('should generate weekly exports when clicked', async ({ page }) => {
      const weeklyBtn = page.locator('#genWeekBtn');
      
      // Listen for response
      const responsePromise = page.waitForResponse(resp => 
        resp.url().includes('/api/admin/generate-week')
      );
      
      await weeklyBtn.click();
      const response = await responsePromise;
      expect(response.status()).toBe(200);
      
      const json = await response.json();
      expect(json.files).toBeDefined();
    });

    test('should generate monthly breakdown when clicked', async ({ page }) => {
      const monthlyBtn = page.locator('#genMonthBtn');
      
      // Listen for response
      const responsePromise = page.waitForResponse(resp => 
        resp.url().includes('/api/admin/generate-month')
      );
      
      await monthlyBtn.click();
      const response = await responsePromise;
      expect(response.status()).toBe(200);
      
      const json = await response.json();
      expect(json.file).toBeDefined();
    });
  });

  // =====================
  // API TESTS
  // =====================
  test.describe('API Endpoints', () => {
    
    test('should return holidays for a given year', async ({ request }) => {
      const response = await request.get('/api/holidays?year=2026');
      expect(response.ok()).toBeTruthy();
      
      const holidays = await response.json();
      expect(Array.isArray(holidays)).toBeTruthy();
      expect(holidays.length).toBeGreaterThan(0);
      
      // Check for expected holidays
      const holidayNames = holidays.map(h => h.name);
      expect(holidayNames).toContain("New Year's Day");
      expect(holidayNames).toContain('Christmas Day');
    });

    test('should return customers list', async ({ request }) => {
      const response = await request.get('/api/customers');
      expect(response.ok()).toBeTruthy();
      
      const customers = await response.json();
      expect(Array.isArray(customers)).toBeTruthy();
    });

    test('should authenticate with valid credentials', async ({ request }) => {
      const response = await request.post('/api/login', {
        data: { name: 'Chris Jacobi', pin: '1111' }
      });
      expect(response.ok()).toBeTruthy();
    });

    test('should reject invalid PIN', async ({ request }) => {
      const response = await request.post('/api/login', {
        data: { name: 'Chris Jacobi', pin: '9999' }
      });
      expect(response.ok()).toBeFalsy();
    });
  });
});

--o--

